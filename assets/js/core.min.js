/* main.js */
/**
 * Main JavaScript
 * Handles navigation, mobile menu, and language switching
 */

(function() {
    'use strict';

    // Mobile Menu Toggle
    const menuToggle = document.getElementById('menu-toggle');
    const navPrimary = document.getElementById('nav-primary');

    if (menuToggle && navPrimary) {
        menuToggle.addEventListener('click', function() {
            const isOpen = navPrimary.classList.toggle('is-open');
            menuToggle.classList.toggle('is-open');
            menuToggle.setAttribute('aria-expanded', isOpen);
        });

        // Close menu when clicking a link
        const navLinks = navPrimary.querySelectorAll('a');
        navLinks.forEach(link => {
            link.addEventListener('click', function() {
                navPrimary.classList.remove('is-open');
                menuToggle.classList.remove('is-open');
                menuToggle.setAttribute('aria-expanded', 'false');
            });
        });

        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            if (!menuToggle.contains(event.target) && !navPrimary.contains(event.target)) {
                navPrimary.classList.remove('is-open');
                menuToggle.classList.remove('is-open');
                menuToggle.setAttribute('aria-expanded', 'false');
            }
        });
    }

    // Language Selector
    const languageSelect = document.getElementById('language-select');

    if (languageSelect) {
        languageSelect.addEventListener('change', function() {
            const newLang = this.value;
            const currentPath = window.location.pathname;

            // Extract current page path after language code
            const pathParts = currentPath.split('/').filter(part => part);
            const currentLang = pathParts[0];

            // Replace language in path
            let newPath = currentPath.replace('/' + currentLang + '/', '/' + newLang + '/');

            // Redirect to new language
            window.location.href = newPath;
        });
    }

    // Active Navigation Link
    const currentPath = window.location.pathname;
    const navLinks = document.querySelectorAll('.nav-primary a');

    navLinks.forEach(link => {
        if (link.getAttribute('href') === currentPath ||
            link.getAttribute('href') + '/' === currentPath ||
            link.getAttribute('href') === currentPath + '/') {
            link.classList.add('active');
            link.setAttribute('aria-current', 'page');
        }
    });

    // Smooth Scroll for Anchor Links
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener('click', function (e) {
            const href = this.getAttribute('href');
            if (href !== '#' && href !== '') {
                e.preventDefault();
                const target = document.querySelector(href);
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            }
        });
    });

    // Contact Form Submission (Web3Forms)
    const contactForm = document.getElementById('contact-form');

    if (contactForm) {
        const statusDiv = document.getElementById('form-status');
        const submitButton = contactForm.querySelector('button[type="submit"]');
        const originalButtonText = submitButton ? submitButton.textContent : '';

        // Get language from hidden field
        const langInput = contactForm.querySelector('input[name="language"]');
        const lang = langInput ? langInput.value : 'en';

        // Translations
        const messages = {
            en: {
                sending: 'Sending...',
                success: 'Message sent successfully! We\'ll get back to you soon.',
                error: 'Error sending message. Please try again or contact us via email.',
                required: 'This field is required',
                invalidEmail: 'Please enter a valid email address'
            },
            ca: {
                sending: 'Enviant...',
                success: 'Missatge enviat correctament! Ens posarem en contacte aviat.',
                error: 'Error enviant el missatge. Si us plau, torna-ho a provar o contacta\'ns per email.',
                required: 'Aquest camp és obligatori',
                invalidEmail: 'Si us plau, introdueix un email vàlid'
            }
        };

        const msg = messages[lang] || messages.en;

        contactForm.addEventListener('submit', async function(e) {
            e.preventDefault();

            // Basic validation
            let isValid = true;
            const requiredFields = this.querySelectorAll('[required]');

            requiredFields.forEach(field => {
                const errorSpan = document.getElementById(field.id + '-error');

                if (!field.value.trim()) {
                    isValid = false;
                    field.classList.add('error');
                    if (errorSpan) {
                        errorSpan.textContent = msg.required;
                    }
                } else {
                    field.classList.remove('error');
                    if (errorSpan) {
                        errorSpan.textContent = '';
                    }
                }
            });

            // Email validation
            const emailField = this.querySelector('[type="email"]');
            if (emailField && emailField.value) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                const errorSpan = document.getElementById(emailField.id + '-error');

                if (!emailRegex.test(emailField.value)) {
                    isValid = false;
                    emailField.classList.add('error');
                    if (errorSpan) {
                        errorSpan.textContent = msg.invalidEmail;
                    }
                }
            }

            if (!isValid) {
                return;
            }

            // Show sending state
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.textContent = msg.sending;
            }

            // Submit form via fetch
            const formData = new FormData(this);

            try {
                const response = await fetch('https://api.web3forms.com/submit', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    // Success
                    statusDiv.textContent = msg.success;
                    statusDiv.className = 'form-status success';
                    this.reset();
                } else {
                    // Error from Web3Forms
                    statusDiv.textContent = msg.error;
                    statusDiv.className = 'form-status error';
                }
            } catch (error) {
                // Network error
                statusDiv.textContent = msg.error;
                statusDiv.className = 'form-status error';
            } finally {
                // Reset button
                if (submitButton) {
                    submitButton.disabled = false;
                    submitButton.textContent = originalButtonText;
                }
            }
        });
    }

    // Print Friendly
    window.addEventListener('beforeprint', function() {
        document.body.classList.add('is-printing');
    });

    window.addEventListener('afterprint', function() {
        document.body.classList.remove('is-printing');
    });

})();

/* cookie-consent.js */
/**
 * Cookie Consent Banner
 * GDPR-compliant cookie consent management
 */

(function() {
    'use strict';

    const CONSENT_KEY = 'cookieConsent';
    const CONSENT_TIMESTAMP_KEY = 'cookieConsentTimestamp';
    const CONSENT_EXPIRY_DAYS = 365;

    const banner = document.getElementById('cookie-banner');
    const acceptButton = document.getElementById('cookie-accept');
    const declineButton = document.getElementById('cookie-decline');

    if (!banner || !acceptButton || !declineButton) {
        console.error('Cookie banner elements not found');
        return;
    }

    /**
     * Check if consent is still valid
     */
    function isConsentValid() {
        const timestamp = localStorage.getItem(CONSENT_TIMESTAMP_KEY);
        if (!timestamp) return false;

        const consentDate = new Date(parseInt(timestamp));
        const now = new Date();
        const daysSinceConsent = (now - consentDate) / (1000 * 60 * 60 * 24);

        return daysSinceConsent < CONSENT_EXPIRY_DAYS;
    }

    /**
     * Check if we should show the banner
     */
    function shouldShowBanner() {
        const consent = localStorage.getItem(CONSENT_KEY);

        // Show if no consent or consent expired
        if (!consent || !isConsentValid()) {
            return true;
        }

        return false;
    }

    /**
     * Show the banner
     */
    function showBanner() {
        banner.classList.add('is-visible');
        banner.setAttribute('aria-hidden', 'false');
    }

    /**
     * Hide the banner
     */
    function hideBanner() {
        banner.classList.remove('is-visible');
        banner.setAttribute('aria-hidden', 'true');
    }

    /**
     * Save consent choice
     */
    function saveConsent(accepted) {
        const choice = accepted ? 'accepted' : 'declined';
        localStorage.setItem(CONSENT_KEY, choice);
        localStorage.setItem(CONSENT_TIMESTAMP_KEY, Date.now().toString());

        // Dispatch custom event for other scripts to listen
        const event = new CustomEvent('consentChanged', {
            detail: { consent: choice }
        });
        window.dispatchEvent(event);

        console.log('Cookie consent:', choice);
    }

    /**
     * Handle accept
     */
    function handleAccept() {
        saveConsent(true);
        hideBanner();

        // Reload to load analytics if needed
        setTimeout(() => {
            window.location.reload();
        }, 300);
    }

    /**
     * Handle decline
     */
    function handleDecline() {
        saveConsent(false);
        hideBanner();
    }

    /**
     * Initialize
     */
    function init() {
        // Check if we should show the banner
        if (shouldShowBanner()) {
            // Small delay for better UX
            setTimeout(showBanner, 1000);
        }

        // Event listeners
        acceptButton.addEventListener('click', handleAccept);
        declineButton.addEventListener('click', handleDecline);

        // Keyboard accessibility
        banner.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                handleDecline();
            }
        });
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // Expose API for testing/debugging
    window.cookieConsent = {
        get: () => localStorage.getItem(CONSENT_KEY),
        reset: () => {
            localStorage.removeItem(CONSENT_KEY);
            localStorage.removeItem(CONSENT_TIMESTAMP_KEY);
            window.location.reload();
        },
        show: showBanner
    };

})();

/* lazy-load.js */
/**
 * Lazy Loading Images
 * Uses IntersectionObserver for performance
 */

(function() {
    'use strict';

    // Check for IntersectionObserver support
    if (!('IntersectionObserver' in window)) {
        console.log('IntersectionObserver not supported, loading all images immediately');
        loadAllImages();
        return;
    }

    const imageObserver = new IntersectionObserver(
        function(entries, observer) {
            entries.forEach(function(entry) {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    loadImage(img);
                    observer.unobserve(img);
                }
            });
        },
        {
            // Start loading slightly before image enters viewport
            rootMargin: '50px 0px',
            threshold: 0.01
        }
    );

    /**
     * Load a single image
     */
    function loadImage(img) {
        const src = img.getAttribute('src');

        if (!src || img.classList.contains('loaded')) {
            return;
        }

        // Create a new image to preload
        const tempImg = new Image();

        tempImg.onload = function() {
            img.classList.add('loaded');
            img.removeAttribute('loading');
        };

        tempImg.onerror = function() {
            console.error('Failed to load image:', src);
            img.classList.add('error');
        };

        tempImg.src = src;
    }

    /**
     * Load all images (fallback for unsupported browsers)
     */
    function loadAllImages() {
        const images = document.querySelectorAll('.lazy-image');
        images.forEach(loadImage);
    }

    /**
     * Initialize lazy loading
     */
    function init() {
        const lazyImages = document.querySelectorAll('.lazy-image');

        lazyImages.forEach(function(img) {
            // Check if image is already in cache
            if (img.complete && img.naturalHeight !== 0) {
                img.classList.add('loaded');
            } else {
                imageObserver.observe(img);
            }
        });

        console.log(`Lazy loading initialized for ${lazyImages.length} images`);
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // Re-initialize if new images are added dynamically
    window.reinitLazyLoad = init;

})();

/* animations.js */
document.addEventListener('DOMContentLoaded', () => {
  // Enable animations only if JS runs
  document.body.classList.add('js-active');

  const observerOptions = {
    root: null,
    rootMargin: '0px',
    threshold: 0.1
  };

  const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('visible');
        observer.unobserve(entry.target); // Only animate once
      }
    });
  }, observerOptions);

  const scrollElements = document.querySelectorAll('.scroll-reveal');
  scrollElements.forEach(el => observer.observe(el));
});
